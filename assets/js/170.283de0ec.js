(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{482:function(a,s,t){"use strict";t.r(s);var e=t(14),n=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"dc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dc"}},[a._v("#")]),a._v(" dc")]),a._v(" "),s("p",[a._v("任意精度计算器")]),a._v(" "),s("h2",{attrs:{id:"说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[a._v("#")]),a._v(" 说明")]),a._v(" "),s("p",[a._v("dc 是一款逆波兰表达式计算器，支持无限制精度的算术运算。它还允许您定义和调用宏。通常，dc从标准输入读取，也可以通过参数传入文件来求值。")]),a._v(" "),s("h2",{attrs:{id:"语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[a._v("#")]),a._v(" 语法")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[a._v("dc")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("选项"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("文件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("..")]),a._v("."),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n")])])]),s("h3",{attrs:{id:"选项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选项"}},[a._v("#")]),a._v(" 选项")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("-e, "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--expression")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("EXPR    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 评估表达式")]),a._v("\n-f, "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--file")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("FILE          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 评估文件内容")]),a._v("\n-h, "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--help")]),a._v("               "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 显示此帮助并退出")]),a._v("\n-V, "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--version")]),a._v("            "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 输出版本信息并退出")]),a._v("\n")])])]),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("p 打印堆栈顶部的值并以换行符结束语句。\nn 打印堆栈顶部的值并以空语句结束行。\nf 打印整个堆栈，不做任何更改。\nP 从栈顶弹出值。\nc 清除堆栈。\nd 复制顶部值并将其推入主堆栈。\nr 反转堆栈中顶部两个元素的顺序。\nZ 从堆栈中弹出值，计算其中的位数并压入该数字。\nX 从堆栈中弹出值，计算其中的小数位数并压入该数字。\nz 将堆栈长度推入堆栈。\ni 从堆栈中弹出值并将其用作输入基数。\no 从堆栈中弹出值并将其用作输出基数。\nk 从堆栈中弹出值并使用它来设置精度。\nI 将输入基数的值推入堆栈。\nO 将输出基数的值压入堆栈\nK 将精度值压入堆栈。\n")])])]),s("h2",{attrs:{id:"示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[a._v("#")]),a._v(" 示例")]),a._v(" "),s("p",[a._v("下面是 "),s("code",[a._v("dc")]),a._v(" 命令在命令行完成的计算 "),s("code",[a._v("10 * 10")]),a._v(" 得出结果 "),s("code",[a._v("100")]),a._v("，并推出的过程")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("dc")]),a._v("        \n\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),a._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 1. 输入数字10")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),a._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 2. 输入数字10")]),a._v("\n*           "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 3. 输入运算类型*表示乘")]),a._v("\np           "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 4. 输入p得到计算结果")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v("\nq           "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 5. 输入 q 退出 dc")]),a._v("\n")])])]),s("p",[a._v("示例显示在命令行结果 "),s("code",[a._v("509")])]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("dc")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--expression")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"50 10 * 9 + p"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("509")]),a._v("\n")])])]),s("h2",{attrs:{id:"支持的运算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#支持的运算"}},[a._v("#")]),a._v(" 支持的运算")]),a._v(" "),s("p",[s("code",[a._v("+")]),a._v(" 从堆栈中弹出两个值，将它们相加，然后压栈结果。")]),a._v(" "),s("p",[s("code",[a._v("-")]),a._v(" 弹出两个值，从弹出的第二个值中减去弹出的第一个值，并压栈结果。")]),a._v(" "),s("p",[s("code",[a._v("*")]),a._v(" 弹出两个值，将它们相乘，然后压栈结果。结果中分数位数取决于当前精度值和两个参数中的分数位数。")]),a._v(" "),s("p",[s("code",[a._v("/")]),a._v(" 弹出两个值，将弹出的第二个值与弹出的第一个值相除，然后推送结果。分数位数由精度值指定。")]),a._v(" "),s("p",[s("code",[a._v("%")]),a._v(" 弹出两个值，计算/命令将执行的除法的剩余部分，并推送该值。计算的值与序列 "),s("code",[a._v("Sd dld/Ld*-")]),a._v("计算的值相同。")]),a._v(" "),s("p",[s("code",[a._v("~")]),a._v(" 弹出两个值，将弹出的第二个值与弹出的第一个值相除。首先推送商，然后推送余数。除法中使用的小数位数由精度值指定。")]),a._v(" "),s("p",[a._v("（序列 SdSn lnld/lnld% 也可以完成此功能，但错误检查略有不同。）")]),a._v(" "),s("p",[s("code",[a._v("^")]),a._v(" 使用弹出的第一个值作为指数，第二个值作为基数，弹出两个值并进行幂运算。忽略指数的分数部分。")]),a._v(" "),s("p",[s("code",[a._v("|")]),a._v(" 弹出三个值并计算模幂。 弹出的第一个值用作约简模数； 这个值必须是一个非零数字，并且应该是一个整数。 弹出的第二个用作指数； 该值必须是非负数，并且该指数的任何小数部分都将被忽略。 弹出的第三个值是取幂的基数，它应该是一个整数。 对于小整数，这类似于序列 Sm^Lm%，但与 ^ 不同的是，此命令适用于任意大的指数。")]),a._v(" "),s("p",[s("code",[a._v("v")]),a._v(" 弹出一个值，计算其平方根，然后压栈它。精度值的最大值和参数的精度用于确定结果中的小数位数。")])])}),[],!1,null,null,null);s.default=n.exports}}]);